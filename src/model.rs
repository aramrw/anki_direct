use std::{borrow::Cow, collections::HashMap};

use derive_builder::Builder;
use futures::future::try_join_all;
use indexmap::IndexMap;
use num_traits::PrimInt;
use serde::{Deserialize, Serialize};

use crate::{
    error::AnkiError,
    generic::{GenericRequest, GenericRequestBuilder},
    Backend, ModelsProxy, Number,
};

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NoteType {
    Regular(RegNoteType),
    Cloze(ClozeNoteType),
}

#[derive(Clone, Debug, Serialize, Deserialize, Builder)]
pub struct RegNoteType {
    #[builder(setter(custom))]
    pub id: Number,
    pub name: String,
    pub fields: Vec<String>,
    pub card_templates: Vec<CardTemplate>,
}
impl RegNoteTypeBuilder {
    /// Custom setter for the `id` field.
    /// This method is NOT generated by derive_builder. We wrote it.
    /// It can be generic to accept any primitive integer.
    pub fn id(&mut self, val: impl PrimInt) -> &mut Self {
        self.id = Some(Number::new(val));
        self
    }
}

#[derive(Clone, Debug, Serialize, Deserialize, Builder)]
pub struct ClozeNoteType {
    #[builder(setter(custom))]
    pub id: Number,
    pub name: String,
    pub fields: Vec<String>,
    pub card_template: CardTemplate,
}
impl ClozeNoteTypeBuilder {
    /// Custom setter for the `id` field.
    /// This method is NOT generated by derive_builder. We wrote it.
    /// It can be generic to accept any primitive integer.
    pub fn id(&mut self, val: impl PrimInt) -> &mut Self {
        self.id = Some(Number::new(val));
        self
    }
}

// In anki::models::card_template
#[derive(Clone, Debug, Serialize, Deserialize, Builder, Default)]
pub struct CardTemplate {
    pub name: String,
    // HTML template
    pub front: String,
    // HTML template
    pub back: String,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ModelTemplates {
    // The API returns a dictionary where the key is the card template name.
    #[serde(flatten)]
    pub templates: HashMap<String, TemplateInfo>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TemplateInfo {
    #[serde(rename = "Front")]
    pub front: String,
    #[serde(rename = "Back")]
    pub back: String,
}
// Result for "modelStyling"
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelStyling {
    pub css: String,
    #[serde(default)]
    pub is_cloze: bool,
}

/// Version of [FullModelDetails] that excludes the `templates` & `styling` fields
/// It's recommended to call this if you only need the name and fields as it doesn't need to make extra requests
#[derive(Clone, Debug)]
pub struct LessModelDetails {
    pub name: String,
    pub fields: Vec<String>,
}

#[derive(Clone, Debug)]
pub struct FullModelDetails {
    pub name: String,
    pub fields: Vec<String>,
    pub templates: ModelTemplates,
    pub styling: ModelStyling,
}
impl FullModelDetails {
    /// A convenient helper to know if this model is a Cloze type.
    pub fn is_cloze(&self) -> bool {
        self.styling.is_cloze
    }
}

#[derive(Clone, Debug, Serialize)]
#[serde(rename_all = "camelCase")]
struct ModelNameParams {
    model_name: String,
}

impl ModelsProxy {
    /// Returns: `Map<(name, id)>`
    async fn get_all_model_names_and_ids(&self) -> Result<IndexMap<String, Number>, AnkiError> {
        type ModelsResult = IndexMap<String, Number>;
        let payload: GenericRequest<()> = GenericRequestBuilder::default()
            .action("modelNamesAndIds".into())
            .version(self.version)
            .build()
            .unwrap();
        self.post_generic_request::<ModelsResult>(payload).await
    }

    /// Get all models found in current anki session.
    /// Returns: `Map<(name, details)>`
    ///
    /// # Example
    ///
    /// This function can be used to update a cache:
    /// ```no_run
    /// #[derive(Default)]
    /// struct ModelCache(IndexMap<String, LessModelDetails);
    ///
    /// static CACHE: LazyLock<RwLock<ModelCache>> = LazyLock::new(|| {
    ///     ModelCache::default().into()
    /// })
    ///
    /// impl ModelCache {
    ///     async fn update() {
    ///         let ac = AnkiClient::default_latest();
    ///         let latest = ac.get_all_models_less().await.expect("u have no models");
    ///         let mut cache = CACHE.write().unwrap();
    ///         cache = latest;
    ///     }
    /// }
    /// ```
    pub async fn get_all_models_less(
        &self,
    ) -> Result<IndexMap<String, LessModelDetails>, AnkiError> {
        let indexmap = self.get_all_model_names_and_ids().await?;
        let futures = indexmap
            .into_iter()
            .map(move |(name, _id)| self.get_less_model_details_by_name(name.into()));
        let details = try_join_all(futures.into_iter()).await?;
        let res: IndexMap<String, LessModelDetails> =
            details.into_iter().map(|d| (d.name.clone(), d)).collect();
        Ok(res)
    }

    /// Fetches the complete list of field names for the provided model name.
    /// https://git.sr.ht/~foosoft/anki-connect#codemodelfieldnamescode
    pub async fn get_model_field_names(&self, model_name: &str) -> Result<Vec<String>, AnkiError> {
        let params = ModelNameParams {
            model_name: model_name.to_string(),
        };
        let payload: GenericRequest<_> = GenericRequestBuilder::default()
            .action("modelFieldNames".into())
            .version(self.version)
            .params(Some(params))
            .build()
            .unwrap();
        self.post_generic_request(payload).await
    }

    /// Fetches the card templates for the provided model name.
    /// Corresponds to the "modelTemplates" action.
    pub async fn get_model_templates(&self, model_name: &str) -> Result<ModelTemplates, AnkiError> {
        let params = ModelNameParams {
            model_name: model_name.to_string(),
        };
        let payload: GenericRequest<_> = GenericRequestBuilder::default()
            .action("modelTemplates".into())
            .version(self.version)
            .params(Some(params))
            .build()
            .unwrap();
        self.post_generic_request(payload).await
    }

    /// Fetches the CSS styling and cloze status for the provided model name.
    /// Corresponds to the "modelStyling" action.
    pub async fn get_model_styling(&self, model_name: &str) -> Result<ModelStyling, AnkiError> {
        let params = ModelNameParams {
            model_name: model_name.to_string(),
        };
        let payload: GenericRequest<_> = GenericRequestBuilder::default()
            .action("modelStyling".into())
            .version(self.version)
            .params(Some(params))
            .build()
            .unwrap();
        self.post_generic_request(payload).await
    }

    /// Fetches all the details for a model by concurrently calling:
    /// [Self::get_model_field_names]
    /// [Self::get_model_templates]
    /// [Self::get_model_styling]
    pub async fn get_full_model_details_by_name(
        &self,
        model_name: &str,
    ) -> Result<FullModelDetails, AnkiError> {
        let (fields, templates, styling) = tokio::try_join!(
            self.get_model_field_names(model_name),
            self.get_model_templates(model_name),
            self.get_model_styling(model_name)
        )?;

        Ok(FullModelDetails {
            name: model_name.to_string(),
            fields,
            templates,
            styling,
        })
    }

    pub async fn get_less_model_details_by_name(
        &self,
        model_name: Cow<'_, str>,
    ) -> Result<LessModelDetails, AnkiError> {
        let fields = self.get_model_field_names(&model_name).await?;
        Ok(LessModelDetails {
            name: model_name.to_string(),
            fields,
        })
    }
}

#[cfg(test)]
mod modeltests {
    use crate::{error::AnkiResult, test_utils::ANKICLIENT};

    #[tokio::test]
    async fn get_all_model_names_and_ids() {
        let res = ANKICLIENT
            .models()
            .get_all_model_names_and_ids()
            .await
            .unwrap();
        assert!(!res.is_empty());
        dbg!(res);
    }

    #[tokio::test]
    async fn get_full_model_details() {
        let res = ANKICLIENT
            .models()
            .get_all_model_names_and_ids()
            .await
            .unwrap();
        assert!(!res.is_empty());
        let first = res.first().unwrap();
        let res = ANKICLIENT
            .models()
            .get_full_model_details_by_name(first.0)
            .await
            .map_err(|e| e.pretty_panic())
            .unwrap();
        dbg!(res);
    }

    #[tokio::test]
    async fn get_less_model_details() -> AnkiResult<()> {
        let res = ANKICLIENT
            .models()
            .get_all_model_names_and_ids()
            .await?;
        assert!(!res.is_empty());
        let first = res.first().unwrap();
        let res = ANKICLIENT
            .models()
            .get_less_model_details_by_name(first.0.into())
            .await?;
        dbg!(res);
        Ok(())
    }

    #[tokio::test]
    async fn get_all_models_less() {
        let res = ANKICLIENT.models().get_all_models_less().await.unwrap();
        assert!(!res.is_empty());
        dbg!(res);
    }
}
